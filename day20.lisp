(eval-when (:execute :compile-toplevel :load-toplevel)
  (ql:quickload '(:iterate
                  :cl-arrows
                  :cl-ppcre
                  :metabang-bind
                  :anaphora
                  :trivia
                  :trivia.ppcre
                  :cl-heap))
  (load "./file.lisp")
  (defpackage :day20
    (:use :common-lisp)
    (:use :file)
    (:use :iterate)
    (:use :cl-arrows)
    (:use :cl-ppcre)
    (:use :metabang-bind)
    (:use :anaphora)
    (:use :trivia)
    (:use :trivia.ppcre)
    (:use :cl-heap))
  (in-package :day20))

#+nil
(file-lines 20)

(defun up (tile)
  (match tile
    ((list* _ (list up _ _ _)) up)))

(defun right (tile)
  (match tile
    ((list* _ (list _ right _ _)) right)))

(defun down (tile)
  (match tile
    ((list* _ (list _ _ down _)) down)))

(defun left (tile)
  (match tile
    ((list* _ (list _ _ _ left)) left)))

(defun works (tile x y grid)
  (bind (((id . (u r d l)) tile)
         (up-tile          (gethash (cons x (1- y)) grid))
         (right-tile       (gethash (cons (1+ x) y) grid))
         (down-tile        (gethash (cons x (1+ y)) grid))
         (left-tile        (gethash (cons (1- x) y) grid))
         (orientations     (list )))
    ;; Standard orientation
    (when (and (or (null up-tile)
              (string-equal u (down up-tile)))
          (or (null right-tile)
              (string-equal r (left right-tile)))
          (or (null down-tile)
              (string-equal d (up down-tile)))
          (or (null left-tile)
              (string-equal l (right left-tile))))
      (push tile orientations))
    ;; Rot: 90
    (bind (((u r d l) (list r (reverse d) l (reverse u))))
      (when (and (or (null up-tile)
                (string-equal u (down up-tile)))
            (or (null right-tile)
                (string-equal r (left right-tile)))
            (or (null down-tile)
                (string-equal d (up down-tile)))
            (or (null left-tile)
                (string-equal l (right left-tile))))
        (push (cons id (list u r d l)) orientations))
      ;; Rot: 180 (Hack!  Rotate the block rotated by 90! XD)
      (bind (((u r d l) (list r (reverse d) l (reverse u))))
        (when (and (or (null up-tile)
                  (string-equal u (down up-tile)))
              (or (null right-tile)
                  (string-equal r (left right-tile)))
              (or (null down-tile)
                  (string-equal d (up down-tile)))
              (or (null left-tile)
                  (string-equal l (right left-tile))))
          (push (cons id (list u r d l)) orientations))
        ;; Rot: 270 (Hack!  Rotate the block rotated by 180! XD)
        (bind (((u r d l) (list r (reverse d) l (reverse u))))
          (when (and (or (null up-tile)
                    (string-equal u (down up-tile)))
                (or (null right-tile)
                    (string-equal r (left right-tile)))
                (or (null down-tile)
                    (string-equal d (up down-tile)))
                (or (null left-tile)
                    (string-equal l (right left-tile))))
            (push (cons id (list u r d l)) orientations)))))
    ;; Flip over vertical axis
    (bind (((u r d l) (list (reverse u) l (reverse d) r)))
      (when (and (or (null up-tile)
                (string-equal u (down up-tile)))
            (or (null right-tile)
                (string-equal r (left right-tile)))
            (or (null down-tile)
                (string-equal d (up down-tile)))
            (or (null left-tile)
                (string-equal l (right left-tile))))
        (push (cons id (list u r d l)) orientations))
      ;; Then do rotations...
      ;; Rot: 90
      (bind (((u r d l) (list r (reverse d) l (reverse u))))
        (when (and (or (null up-tile)
                  (string-equal u (down up-tile)))
              (or (null right-tile)
                  (string-equal r (left right-tile)))
              (or (null down-tile)
                  (string-equal d (up down-tile)))
              (or (null left-tile)
                  (string-equal l (right left-tile))))
          (push (cons id (list u r d l)) orientations))
        ;; Rot: 180 (Hack!  Rotate the block rotated by 90! XD)
        (bind (((u r d l) (list r (reverse d) l (reverse u))))
          (when (and (or (null up-tile)
                    (string-equal u (down up-tile)))
                (or (null right-tile)
                    (string-equal r (left right-tile)))
                (or (null down-tile)
                    (string-equal d (up down-tile)))
                (or (null left-tile)
                    (string-equal l (right left-tile))))
            (push (cons id (list u r d l)) orientations))
          ;; Rot: 270 (Hack!  Rotate the block rotated by 180! XD)
          (bind (((u r d l) (list r (reverse d) l (reverse u))))
            (when (and (or (null up-tile)
                      (string-equal u (down up-tile)))
                  (or (null right-tile)
                      (string-equal r (left right-tile)))
                  (or (null down-tile)
                      (string-equal d (up down-tile)))
                  (or (null left-tile)
                      (string-equal l (right left-tile))))
              (push (cons id (list u r d l)) orientations))))))
    ;; Flip over horizontal axis
    (bind (((u r d l) (list d (reverse r) u (reverse l))))
      (when (and (or (null up-tile)
                (string-equal u (down up-tile)))
            (or (null right-tile)
                (string-equal r (left right-tile)))
            (or (null down-tile)
                (string-equal d (up down-tile)))
            (or (null left-tile)
                (string-equal l (right left-tile))))
        (push (cons id (list u r d l)) orientations))
      ;; Then do rotations...
      ;; Rot: 90
      (bind (((u r d l) (list r (reverse d) l (reverse u))))
        (when (and (or (null up-tile)
                  (string-equal u (down up-tile)))
              (or (null right-tile)
                  (string-equal r (left right-tile)))
              (or (null down-tile)
                  (string-equal d (up down-tile)))
              (or (null left-tile)
                  (string-equal l (right left-tile))))
          (push (cons id (list u r d l)) orientations))
        ;; Rot: 180 (Hack!  Rotate the block rotated by 90! XD)
        (bind (((u r d l) (list r (reverse d) l (reverse u))))
          (when (and (or (null up-tile)
                    (string-equal u (down up-tile)))
                (or (null right-tile)
                    (string-equal r (left right-tile)))
                (or (null down-tile)
                    (string-equal d (up down-tile)))
                (or (null left-tile)
                    (string-equal l (right left-tile))))
            (push (cons id (list u r d l)) orientations))
          ;; Rot: 270 (Hack!  Rotate the block rotated by 180! XD)
          (bind (((u r d l) (list r (reverse d) l (reverse u))))
            (when (and (or (null up-tile)
                      (string-equal u (down up-tile)))
                  (or (null right-tile)
                      (string-equal r (left right-tile)))
                  (or (null down-tile)
                      (string-equal d (up down-tile)))
                  (or (null left-tile)
                      (string-equal l (right left-tile))))
              (push (cons id (list u r d l)) orientations))))))
    orientations))

(defun arrange-tiles (tiles grid spots-taken)
  (if (null tiles)
      grid
      (iter
        (for tile in tiles)
        (thereis
         (iter outer
           (for (x . y) in spots-taken)
           (for up-free    = (null (gethash (cons x (1- y)) grid)))
           (awhen (and up-free (works tile x (1- y) grid))
             (iter
               (for orientation in it)
               (setf (gethash (cons x (1- y)) grid) orientation)
               (aif (arrange-tiles (remove tile tiles) grid (cons (cons x (1- y)) spots-taken))
                    (in outer (leave it))
                    (remhash (cons x (1- y)) grid))))
           (for right-free = (null (gethash (cons (1+ x) y) grid)))
           (awhen (and right-free (works tile (1+ x) y grid))
             (iter
               (for orientation in it)
               (setf (gethash (cons (1+ x) y) grid) orientation)
               (aif (arrange-tiles (remove tile tiles) grid (cons (cons (1+ x) y) spots-taken))
                    (in outer (leave it))
                    (remhash (cons (1+ x) y) grid))))
           (for down-free  = (null (gethash (cons x (1+ y)) grid)))
           (awhen (and down-free (works tile x (1+ y) grid))
             (iter
               (for orientation in it)
               (setf (gethash (cons x (1+ y)) grid) orientation)
               (aif (arrange-tiles (remove tile tiles) grid (cons (cons x (1+ y)) spots-taken))
                    (in outer (leave it))
                    (remhash (cons x (1+ y)) grid))))
           (for left-free  = (null (gethash (cons (1- x) y) grid)))
           (awhen (and left-free (works tile (1- x) y grid))
             (iter
               (for orientation in it)
               (setf (gethash (cons (1- x) y) grid) orientation)
               (aif (arrange-tiles (remove tile tiles) grid (cons (cons (1- x) y) spots-taken))
                    (in outer (leave it))
                    (remhash (cons (1- x) y) grid)))))))))

(defun part-1 ()
  (bind ((tiles (->> (file-string 20)
                  (split (create-scanner '(:sequence #\Newline #\Newline)))
                  (mapcar (lambda (raw-tile)
                            (match (split (create-scanner #\Newline) raw-tile)
                              ((list* id-row rest)
                               (cons (-<> (split "[^0-9]" id-row)
                                       (remove "" <> :test #'string-equal)
                                       (car <>)
                                       (read-from-string <>))
                                     (bind ((blocks (map 'vector #'identity rest))
                                            (x-dim  (length (aref blocks 0)))
                                            (top    (aref blocks 0))
                                            (bottom (aref blocks (1- (length blocks))))
                                            (l-col   (iter
                                                       (for y from 0 below (length blocks))
                                                       (collecting (-> (aref blocks y) (aref 0))
                                                                   :result-type 'string)))
                                            (r-col  (iter
                                                      (for y from 0 below (length blocks))
                                                      (collecting (-> (aref blocks y) (aref (1- x-dim)))
                                                                  :result-type 'string))))
                                       (list top r-col bottom l-col)))))))))
         (grid (make-hash-table :test #'equal)))
    (setf (gethash (cons 0 0) grid) (car tiles))
    (arrange-tiles (cdr tiles)
                   grid
                   (list (cons 0 0)))
    (iter
      (for (key value) in-hashtable grid)
      (minimizing (car key) into min-x)
      (maximizing (car key) into max-x)
      (minimizing (cdr key) into min-y)
      (maximizing (cdr key) into max-y)
      (finally
       (return
         (* (car (gethash (cons min-x min-y) grid))
            (car (gethash (cons max-x min-y) grid))
            (car (gethash (cons min-x max-y) grid))
            (car (gethash (cons max-x max-y) grid))))))))

(defun part-2 ()
  (bind ((tiles (->> (file-string 20)
                  (split (create-scanner '(:sequence #\Newline #\Newline)))
                  (mapcar (lambda (raw-tile)
                            (match (split (create-scanner #\Newline) raw-tile)
                              ((list* id-row rest)
                               (cons (-<> (split "[^0-9]" id-row)
                                       (remove "" <> :test #'string-equal)
                                       (car <>)
                                       (read-from-string <>))
                                     (bind ((blocks (map 'vector #'identity rest))
                                            (x-dim  (length (aref blocks 0)))
                                            (top    (aref blocks 0))
                                            (bottom (aref blocks (1- (length blocks))))
                                            (l-col   (iter
                                                       (for y from 0 below (length blocks))
                                                       (collecting (-> (aref blocks y) (aref 0))
                                                                   :result-type 'string)))
                                            (r-col  (iter
                                                      (for y from 0 below (length blocks))
                                                      (collecting (-> (aref blocks y) (aref (1- x-dim)))
                                                                  :result-type 'string))))
                                       (list top r-col bottom l-col)))))))))
         (grid (make-hash-table :test #'equal)))
    (setf (gethash (cons 0 0) grid) (car tiles))
    (arrange-tiles (cdr tiles)
                   grid
                   (list (cons 0 0)))
    ))
